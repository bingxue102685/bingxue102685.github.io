






<!doctype html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta name="baidu-site-verification" content="2kT43Dluf4" />
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="ZHJ">
  
  
  
  
    <meta name="description" content="上一篇解读了一下 cocos2d-x 3.x 的渲染流程，最后的渲染工作都交给了 Render类 ，那在 Render类 中具体是怎么渲染的呢？下面就以画一个 sprite 为例，一一解读一下，
sprite 中的 draw 函数sprite 中的draw函数，并没有实际的去使用opengl代码画图，而是生成了一个渲染四边形的命令，加入Render类中的渲染队列。
1234567891011...">
  
  <title>coco2d-x 3.x Render类 [ 奔跑的蜗牛 ]</title>
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/highlight-railscasts.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>

<body>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="side-navigate hide-area">
  
  
    <div class="item next">
      <a href="/2018/01/22/cocos2d-x-3-x渲染流程/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        cocos2d-x 3.x渲染流程
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="/faceicon.jpg"/>
          <div id="homelink">奔跑的蜗牛</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">首页</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">文章</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">标签</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">分类</a>
            
          </li>
        
          
            <li>
          
            <a href="/about">关于</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  <article id="post">
    <h1>coco2d-x 3.x Render类</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">撰写于 2018-01-22</span>
      
        <span id = "post-title-updated">修改于 2018-01-29</span>
      
      
      <span id = "post-title-categories">分类
      
      
        
        
        <a href="/categories/游戏开发/">游戏开发</a>
      
      </span>
      
      
      <span id = "post-title-tags">
      标签
      
      
        
        
        <a href="/tags/cocos2d-x/">cocos2d-x</a>
      
      </span>
      
    </p>
    
    <p>上一篇解读了一下 cocos2d-x 3.x 的渲染流程，最后的渲染工作都交给了 Render类 ，那在 Render类 中具体是怎么渲染的呢？下面就以画一个 sprite 为例，一一解读一下，</p>
<h3 id="sprite-中的-draw-函数"><a href="#sprite-中的-draw-函数" class="headerlink" title="sprite 中的 draw 函数"></a>sprite 中的 draw 函数</h3><p>sprite 中的draw函数，并没有实际的去使用opengl代码画图，而是生成了一个渲染四边形的命令，加入Render类中的渲染队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Sprite::draw(Renderer *renderer, <span class="keyword">const</span> Mat4 &amp;transform, <span class="keyword">uint32_t</span> flags)</div><div class="line">&#123;</div><div class="line">    <span class="comment">/*此处用于判断 node 通过 transform 变化后，是否已经出屏幕了，也就是检测是否被裁剪*/</span></div><div class="line">    _insideBounds = (flags &amp; FLAGS_TRANSFORM_DIRTY) ? renderer-&gt;checkVisibility(transform, _contentSize) : _insideBounds;</div><div class="line">    <span class="comment">/*如果变化之后 还在 屏幕内 则进行渲染*/</span></div><div class="line">    <span class="keyword">if</span>(_insideBounds)</div><div class="line">    &#123;</div><div class="line">    	<span class="comment">/*初始化渲染命令*/</span></div><div class="line">        _quadCommand.init(_globalZOrder, _texture-&gt;getName(), getGLProgramState(), _blendFunc, &amp;_quad, <span class="number">1</span>, transform);</div><div class="line">        <span class="comment">/*加入渲染队列*/</span></div><div class="line">        renderer-&gt;addCommand(&amp;_quadCommand);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Render-addCommand函数"><a href="#Render-addCommand函数" class="headerlink" title="Render::addCommand函数"></a>Render::addCommand函数</h3><p>渲染命令加入到渲染队列（RenderQueue），渲染队列（RenderQueue）又被加入到了不同的 渲染组（RenderGroups） 里面，一般默认的，比如，sprite，lable都是加入到了 默认组（0） 里面，其他特殊node（ClippingNode，RenderTexture，BatchNode）被放到了其他组里面，需要特殊处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Renderer::addCommand(RenderCommand* command)</div><div class="line">&#123;</div><div class="line">	<span class="comment">/*取_commandGroupStack 栈顶*/</span></div><div class="line">    <span class="keyword">int</span> renderQueue =_commandGroupStack.top();</div><div class="line">	<span class="comment">/*renderQueue必选要大于等于零*/</span></div><div class="line">    addCommand(command, renderQueue);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Renderer::addCommand(RenderCommand* command, <span class="keyword">int</span> renderQueue)</div><div class="line">&#123;</div><div class="line">    CCASSERT(!_isRendering, <span class="string">"Cannot add command while rendering"</span>);</div><div class="line">    CCASSERT(renderQueue &gt;=<span class="number">0</span>, <span class="string">"Invalid render queue"</span>);</div><div class="line">    CCASSERT(command-&gt;getType() != RenderCommand::Type::UNKNOWN_COMMAND, <span class="string">"Invalid Command Type"</span>);</div><div class="line">    <span class="comment">/*如果是透明的，则加入到透明渲染组*/</span></div><div class="line">    <span class="keyword">if</span> (command-&gt;isTransparent())</div><div class="line">        _transparentRenderGroups.push_back(command);</div><div class="line">    <span class="keyword">else</span></div><div class="line">   		<span class="comment">/*根据globalOrder &gt;0, &lt;0, =0 分别放进了renderQueue 的 _queuePosZ, _queueNegZ, _queue0*/</span></div><div class="line">        _renderGroups[renderQueue].push_back(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Render-render-函数"><a href="#Render-render-函数" class="headerlink" title="Render::render() 函数"></a>Render::render() 函数</h3><p>其实render函数只处理了 渲染组 0 的渲染队列，其他组的渲染队列需要特殊处理。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Renderer::render()</div><div class="line">&#123;</div><div class="line">    _isRendering = <span class="literal">true</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (_glViewAssigned)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">/*Process render commands</span></div><div class="line">        1. Sort render commands based on ID*/</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;renderqueue : _renderGroups)</div><div class="line">        &#123;</div><div class="line">        	<span class="comment">/*先把 renderqueue 里面的 _queuePosZ, _queueNegZ, 根据globalOrder 从小到大排序*/</span></div><div class="line">            renderqueue.sort();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*renderGroups[0] 中存放的就是 即将渲染的 renderqueue*/</span></div><div class="line">        visitRenderQueue(_renderGroups[<span class="number">0</span>]);</div><div class="line">        flush();</div><div class="line">        </div><div class="line">        <span class="comment">/*Process render commands</span></div><div class="line">        draw transparent objects here, do not batch for transparent objects*/</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt; _transparentRenderGroups.size())</div><div class="line">        &#123;</div><div class="line">            _transparentRenderGroups.sort();</div><div class="line">            glEnable(GL_DEPTH_TEST);</div><div class="line">            visitTransparentRenderQueue(_transparentRenderGroups);</div><div class="line">            glDisable(GL_DEPTH_TEST);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    clean();</div><div class="line">    _isRendering = <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>核心函数 visitRenderQueue 的作用就是遍历渲染队列，延迟渲染。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Renderer::visitRenderQueue(<span class="keyword">const</span> RenderQueue&amp; <span class="built_in">queue</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ssize_t</span> size = <span class="built_in">queue</span>.size();</div><div class="line">    <span class="comment">/*此处进行分类处理 三角形渲染命令 四边形渲染命令  其他的命令暂时不管*/</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">ssize_t</span> index = <span class="number">0</span>; index &lt; size; ++index)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> command = <span class="built_in">queue</span>[index];</div><div class="line">        <span class="keyword">auto</span> commandType = command-&gt;getType();</div><div class="line">        <span class="keyword">if</span>( RenderCommand::Type::TRIANGLES_COMMAND == commandType)</div><div class="line">        &#123;</div><div class="line">            flush3D();</div><div class="line">            <span class="comment">/*此处的目的是，如果上个命令是 四边形渲染命令 且没有去渲染（vbo未填满），则此处强制进行渲染上个命令*/</span></div><div class="line">            <span class="keyword">if</span>(_numberQuads &gt; <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                drawBatchedQuads();</div><div class="line">                _lastMaterialID = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">auto</span> cmd = <span class="keyword">static_cast</span>&lt;TrianglesCommand*&gt;(command);</div><div class="line">            <span class="comment">//Batch Triangles</span></div><div class="line">            <span class="comment">/*如果vbo 已经被填满，则进行批渲染*/</span></div><div class="line">            <span class="keyword">if</span>( _filledVertex + cmd-&gt;getVertexCount() &gt; VBO_SIZE || _filledIndex + cmd-&gt;getIndexCount() &gt; INDEX_VBO_SIZE)</div><div class="line">            &#123;</div><div class="line">                CCASSERT(cmd-&gt;getVertexCount()&gt;= <span class="number">0</span> &amp;&amp; cmd-&gt;getVertexCount() &lt; VBO_SIZE, <span class="string">"VBO for vertex is not big enough, please break the data down or use customized render command"</span>);</div><div class="line">                CCASSERT(cmd-&gt;getIndexCount()&gt;= <span class="number">0</span> &amp;&amp; cmd-&gt;getIndexCount() &lt; INDEX_VBO_SIZE, <span class="string">"VBO for index is not big enough, please break the data down or use customized render command"</span>);</div><div class="line">                <span class="comment">//Draw batched Triangles if VBO is full</span></div><div class="line">                drawBatchedTriangles();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/*如果没有被填满 则加入 批处理 数组*/</span></div><div class="line">            _batchedCommands.push_back(cmd);</div><div class="line">            <span class="comment">/*记录该命令中定点和索引的个数，累计进_filledVertex中*/</span></div><div class="line">            fillVerticesAndIndices(cmd);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( RenderCommand::Type::QUAD_COMMAND == commandType )</div><div class="line">        &#123;</div><div class="line">            flush3D();</div><div class="line">            <span class="comment">/*此处同 三角形的渲染命令类似，如果上个命令是  三角形渲染命令 且没有去渲染（vbo未填满），则此处强制进行渲染上个命令*/</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span>(_filledIndex &gt; <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                drawBatchedTriangles();</div><div class="line">                _lastMaterialID = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> cmd = <span class="keyword">static_cast</span>&lt;QuadCommand*&gt;(command);</div><div class="line">            <span class="comment">/*如果vbo 已经被填满，则进行批渲染*/</span></div><div class="line">            <span class="keyword">if</span>( (_numberQuads + cmd-&gt;getQuadCount()) * <span class="number">4</span> &gt; VBO_SIZE )</div><div class="line">            &#123;</div><div class="line">                CCASSERT(cmd-&gt;getQuadCount()&gt;= <span class="number">0</span> &amp;&amp; cmd-&gt;getQuadCount() * <span class="number">4</span> &lt; VBO_SIZE, <span class="string">"VBO for vertex is not big enough, please break the data down or use customized render command"</span>);</div><div class="line">                <span class="comment">//Draw batched quads if VBO is full</span></div><div class="line">                drawBatchedQuads();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/*如果没有被填满 则加入 批处理 数组*/</span></div><div class="line">            _batchQuadCommands.push_back(cmd);</div><div class="line">            <span class="comment">/*记录该命令中定点和索引的个数，累计进_numberQuads中*/</span></div><div class="line">            fillQuads(cmd);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(RenderCommand::Type::GROUP_COMMAND == commandType)</div><div class="line">        &#123;</div><div class="line">            flush();</div><div class="line">            <span class="keyword">int</span> renderQueueID = ((GroupCommand*) command)-&gt;getRenderQueueID();</div><div class="line">            visitRenderQueue(_renderGroups[renderQueueID]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(RenderCommand::Type::CUSTOM_COMMAND == commandType)</div><div class="line">        &#123;</div><div class="line">            flush();</div><div class="line">            <span class="keyword">auto</span> cmd = <span class="keyword">static_cast</span>&lt;CustomCommand*&gt;(command);</div><div class="line">            cmd-&gt;execute();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(RenderCommand::Type::BATCH_COMMAND == commandType)</div><div class="line">        &#123;</div><div class="line">            flush();</div><div class="line">            <span class="keyword">auto</span> cmd = <span class="keyword">static_cast</span>&lt;BatchCommand*&gt;(command);</div><div class="line">            cmd-&gt;execute();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(RenderCommand::Type::PRIMITIVE_COMMAND == commandType)</div><div class="line">        &#123;</div><div class="line">            flush();</div><div class="line">            <span class="keyword">auto</span> cmd = <span class="keyword">static_cast</span>&lt;PrimitiveCommand*&gt;(command);</div><div class="line">            cmd-&gt;execute();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (RenderCommand::Type::MESH_COMMAND == commandType)</div><div class="line">        &#123;</div><div class="line">            flush2D();</div><div class="line">            <span class="keyword">auto</span> cmd = <span class="keyword">static_cast</span>&lt;MeshCommand*&gt;(command);</div><div class="line">            <span class="keyword">if</span> (_lastBatchedMeshCommand == <span class="literal">nullptr</span> || _lastBatchedMeshCommand-&gt;getMaterialID() != cmd-&gt;getMaterialID())</div><div class="line">            &#123;</div><div class="line">                flush3D();</div><div class="line">                cmd-&gt;preBatchDraw();</div><div class="line">                cmd-&gt;batchDraw();</div><div class="line">                _lastBatchedMeshCommand = cmd;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                cmd-&gt;batchDraw();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            CCLOGERROR(<span class="string">"Unknown commands in renderQueue"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>绘图的过程就是：如果支持vao，则先绑定已经设置好的vao，然后往vbo中填充顶点数据，然后进行绘制；如果不支持vao，则需要设置顶点属性，然后进行绘制。如果绘制命令中使用的材质id相同的话，则不去绘制，记录顶点跨度，如果材质id不同，则进行绘制，自动实现批渲染，减少drawcall次数，所以游戏中把图片打包还是有一定好处的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Renderer::drawBatchedQuads()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> indexToDraw = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/*如果渲染点的数量小于零，或者批渲染命令为空*/</span></div><div class="line">    <span class="keyword">if</span>(_numberQuads &lt;= <span class="number">0</span> || _batchQuadCommands.empty())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*是否支持vao，vao已经在setupVBOAndVAO中进行设置</span></div><div class="line">      如果支持vao，绘图时不用再进行顶点属性的设置，直接设置vbo数据即可，</div><div class="line">    */</div><div class="line">    <span class="keyword">if</span> (Configuration::getInstance()-&gt;supportsShareableVAO())</div><div class="line">    &#123;</div><div class="line">        <span class="comment">/*绑定绘制四边形的vao*/</span></div><div class="line">        GL::bindVAO(_quadVAO);</div><div class="line">        <span class="comment">/*绑定vbo*/</span></div><div class="line">        glBindBuffer(GL_ARRAY_BUFFER, _quadbuffersVBO[<span class="number">0</span>]);</div><div class="line">        <span class="comment">/*生成vbo的空间，此处没有把数据放入当前绑定的vbo中，只是开辟了一个空间*/</span></div><div class="line">        glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(_quadVerts[<span class="number">0</span>]) * _numberQuads * <span class="number">4</span>, <span class="literal">nullptr</span>, GL_DYNAMIC_DRAW);</div><div class="line">        <span class="comment">/*获取生成的vbo指针*/</span></div><div class="line">        <span class="keyword">void</span> *buf = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</div><div class="line">        <span class="comment">/*vbo中放入数据*/</span></div><div class="line">        <span class="built_in">memcpy</span>(buf, _quadVerts, <span class="keyword">sizeof</span>(_quadVerts[<span class="number">0</span>])* _numberQuads * <span class="number">4</span>);</div><div class="line">        <span class="comment">/*解绑*/</span></div><div class="line">        glUnmapBuffer(GL_ARRAY_BUFFER);</div><div class="line">        </div><div class="line">        glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</div><div class="line">        </div><div class="line">        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _quadbuffersVBO[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*一下是不支持vao的顶点属性设置*/</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">#define kQuadSize <span class="keyword">sizeof</span>(_verts[<span class="number">0</span>])</div><div class="line">        glBindBuffer(GL_ARRAY_BUFFER, _quadbuffersVBO[<span class="number">0</span>]);</div><div class="line">        </div><div class="line">        glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(_quadVerts[<span class="number">0</span>]) * _numberQuads * <span class="number">4</span> , _quadVerts, GL_DYNAMIC_DRAW);</div><div class="line">        </div><div class="line">        GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);</div><div class="line">        </div><div class="line">        <span class="comment">/* vertices*/</span></div><div class="line">        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, <span class="number">3</span>, GL_FLOAT, GL_FALSE, kQuadSize, (GLvoid*) offsetof(V3F_C4B_T2F, vertices));</div><div class="line">        </div><div class="line">        <span class="comment">/* colors*/</span></div><div class="line">        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, <span class="number">4</span>, GL_UNSIGNED_BYTE, GL_TRUE, kQuadSize, (GLvoid*) offsetof(V3F_C4B_T2F, colors));</div><div class="line">        </div><div class="line">        <span class="comment">/* tex coords*/</span></div><div class="line">        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, <span class="number">2</span>, GL_FLOAT, GL_FALSE, kQuadSize, (GLvoid*) offsetof(V3F_C4B_T2F, texCoords));</div><div class="line">        </div><div class="line">        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _quadbuffersVBO[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*开始绘制顶点*/</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cmd : _batchQuadCommands)</div><div class="line">    &#123;</div><div class="line">    	<span class="comment">/*获取材质id*/</span></div><div class="line">        <span class="keyword">auto</span> newMaterialID = cmd-&gt;getMaterialID();</div><div class="line">        <span class="comment">/*如果上一个绘制命令的材质同当前命令的材质相同（使用同一张图片），则不渲染，</span></div><div class="line">          如果材质不相同，则开始绘制，实现自动批处理的绘制，有效减少drawcall次数</div><div class="line">        */</div><div class="line">        <span class="keyword">if</span>(_lastMaterialID != newMaterialID || newMaterialID == MATERIAL_ID_DO_NOT_BATCH)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(indexToDraw &gt; <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                glDrawElements(GL_TRIANGLES, (GLsizei) indexToDraw, GL_UNSIGNED_SHORT, (GLvoid*) (startIndex*<span class="keyword">sizeof</span>(_indices[<span class="number">0</span>])) );</div><div class="line">                _drawnBatches++;</div><div class="line">                _drawnVertices += indexToDraw;</div><div class="line">                </div><div class="line">                startIndex += indexToDraw;</div><div class="line">                indexToDraw = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/*Use new material*/</span></div><div class="line">            cmd-&gt;useMaterial();</div><div class="line">            _lastMaterialID = newMaterialID;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        indexToDraw += cmd-&gt;getQuadCount() * <span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*此处是防止游戏命令没有绘制完毕*/</span></div><div class="line">    <span class="keyword">if</span>(indexToDraw &gt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        glDrawElements(GL_TRIANGLES, (GLsizei) indexToDraw, GL_UNSIGNED_SHORT, (GLvoid*) (startIndex*<span class="keyword">sizeof</span>(_indices[<span class="number">0</span>])) );</div><div class="line">        _drawnBatches++;</div><div class="line">        _drawnVertices += indexToDraw;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (Configuration::getInstance()-&gt;supportsShareableVAO())</div><div class="line">    &#123;</div><div class="line">        <span class="comment">/*绘制完毕，解绑VAO*/</span></div><div class="line">        GL::bindVAO(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</div><div class="line">        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    _batchQuadCommands.clear();</div><div class="line">    _numberQuads = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结：以上就是cocos2d-x 3.x的核心渲染部分，相比2.x，渲染部分提高了效率，主要体现以下两个方面：</p>
<ol>
<li>采用延迟渲染的方式，非立即渲染的方式，即把渲染顶点的数量达到vbo的最大容量才进行渲染，减少drawcall次数</li>
<li>自动批渲染，不需要手动添加batchnode，减少drawcall次数。</li>
</ol>

  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">显示目录</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">隐藏目录</button>
  <div class="random-toc">
    <h2>目录</h2>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#sprite-中的-draw-函数"><span class="toc-text">sprite 中的 draw 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Render-addCommand函数"><span class="toc-text">Render::addCommand函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Render-render-函数"><span class="toc-text">Render::render() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
  </div>
</div>

  
<nav id="pagination">
  

  

  
    <a href="/2018/01/22/cocos2d-x-3-x渲染流程/" class="next">下一篇 cocos2d-x 3.x渲染流程 &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
      <div id="uyan_frame"></div>
      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by ZHJ using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>



  <!-- UY BEGIN -->
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2146884"></script>
<!-- UY END -->


  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="/faceicon.jpg">
    <p id="description"></p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/bingxue102685/">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="http://weibo.com/u/2651440571">
        
          <i class="icon iconfont weibo">&#xe602;</i>
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>

  <script>
if(isTriggerAnalytics) {
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?ad51ef187046c9c2ce59ecc66675a383";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
}
</script>





  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/highlight.pack.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["slideLeft2","slideRight2","flash2"],"timer":true,"delay":5000,"shuffle":true,"count":28};
var unsplashConfig = {"gravity":"north"};
// is show background images
var turnoffBackgroundImage = false;



  turnoffBackgroundImage = true;


var backgroundColor = "D7CCC8";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>

